# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zCdNpL2No5-542FN-KoEi-304y1QyQqj
"""

# Commented out IPython magic to ensure Python compatibility.
# Suppress warnings for clean output
import warnings
warnings.filterwarnings('ignore')

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Ensure matplotlib uses Agg backend
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

# For our predictor
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# Set style for seaborn plots
sns.set(style='whitegrid')

# Display version info (if needed for debugging)
print(f"Pandas version: {pd.__version__}")
print(f"Matplotlib version: {matplotlib.__version__}")
print(f"Seaborn version: {sns.__version__}")

# Load the dataset from the CSV file
file_path = '/content/top_rated_2000webseries.csv'
df = pd.read_csv(file_path, encoding='utf-8', delimiter=',')

# Display the first few rows to get an initial sense of the data
print(df.head())

# Display the data types
print(df.dtypes)

# Convert 'premiere_date' to datetime format
# If there are errors in conversion, it is recommended to inspect the problematic rows

df['premiere_date'] = pd.to_datetime(df['premiere_date'], errors='coerce')

# Check for missing values in the dataset
missing_values = df.isnull().sum()
print('Missing values in each column:')
print(missing_values)

# Additional cleaning: If necessary, strip extra spaces from string columns
str_cols = ['title', 'original_title', 'overview', 'genre', 'country_origin', 'original_language']
for col in str_cols:
    df[col] = df[col].astype(str).str.strip()

# Display summary statistics
print(df.describe(include='all'))

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Nom du fichier CSV (doit être dans le même répertoire)
FILE_PATH = 'top_rated_2000webseries.csv'

# ===================================================================
# 1. CHARGEMENT ET PRÉPARATION DES DONNÉES
# (Ne change pas les données, mais assure le bon type pour les calculs)
# ===================================================================
try:
    df = pd.read_csv(FILE_PATH)
except FileNotFoundError:
    print(f"Erreur : Le fichier '{FILE_PATH}' n'a pas été trouvé.")
    exit()

# Conversion des colonnes clés en numérique (gère les erreurs en les convertissant en NaN)
df['rating'] = pd.to_numeric(df['rating'], errors='coerce')
df['popularity'] = pd.to_numeric(df['popularity'], errors='coerce')
df['votes'] = pd.to_numeric(df['votes'], errors='coerce')

# Supprimer les lignes où ces colonnes clés sont manquantes après la conversion
df.dropna(subset=['rating', 'popularity', 'votes', 'country_origin'], inplace=True)

# DataFrame pour les analyses numériques
numeric_df = df[['rating', 'popularity', 'votes']]
# ===================================================================


# ===================================================================
# 2. CARTE DE CHALEUR DE CORRÉLATION (Correlation Heatmap)
# ===================================================================
print("Génération de la Carte de Chaleur de Corrélation...")
if numeric_df.shape[1] >= 2: # Check if there are enough columns
    plt.figure(figsize=(8, 6))
    corr = numeric_df.corr()
    sns.heatmap(corr, annot=True, cmap='coolwarm', fmt='.2f')
    plt.title('Carte de Chaleur de Corrélation des Caractéristiques Numériques')
    plt.tight_layout()
    plt.show()
else:
    print('Pas assez de colonnes numériques pour créer une carte de chaleur de corrélation.')


# ===================================================================
# 3. HISTOGRAMMES (Distribution) pour Rating, Popularity et Votes
# ===================================================================
print("Génération des Histogrammes de Distribution...")
plt.figure(figsize=(15, 4))

# Distribution des Notes (Rating)
plt.subplot(1,3,1)
sns.histplot(df['rating'], kde=True, color='skyblue')
plt.title('Distribution des Notes (Rating)')

# Distribution de la Popularité (Popularity)
plt.subplot(1,3,2)
sns.histplot(df['popularity'], kde=True, color='salmon')
plt.title('Distribution de la Popularité')

# Distribution des Votes (Votes)
plt.subplot(1,3,3)
sns.histplot(df['votes'], kde=True, color='lightgreen')
plt.title('Distribution des Votes')

plt.tight_layout()
plt.show()


# ===================================================================
# 4. DIAGRAMME DE COMPTAGE par Pays d'Origine (Top 10)
# ===================================================================
print("Génération du Diagramme de Comptage par Pays d'Origine...")
plt.figure(figsize=(10, 6))

# Identifier et filtrer les 10 pays les plus fréquents pour la clarté
top_countries = df['country_origin'].value_counts().head(10).index
df_top_countries = df[df['country_origin'].isin(top_countries)]

# Utiliser le top 10 comme ordre
sns.countplot(y='country_origin', data=df_top_countries, order=top_countries, palette='viridis')
plt.title('Top 10 Séries par Pays d\'Origine')
plt.xlabel('Nombre de Séries')
plt.ylabel('Pays d\'Origine')
plt.tight_layout()
plt.show()


# ===================================================================
# 5. PAIR PLOT pour les Caractéristiques Numériques
# ===================================================================
print("Génération du Pair Plot...")
# Le Pair Plot affiche la distribution de chaque variable et leur relation croisée
sns.pairplot(numeric_df, diag_kind='kde')
plt.suptitle('Pair Plot des Caractéristiques Numériques (Rating, Popularité, Votes)', y=1.02)
plt.show()

print("\nAnalyse exploratoire terminée.")